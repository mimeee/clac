快排算法

partition:   
分区，一个数的左部分必须全部小于这个数，一个数的右部分必须全部大于这个数。比如[1,5,9,8,3,4,6];选取这个数为8则数组变为[1,5,3,4,6,8,9];  
具体步骤： 当小于等于划分值，与小于等于区下一个值交换，区扩，边界跳下一个

快排就是荷兰国旗问题，未改进的快排序只是把最后一个数字作为border来界定左右区间。

改进的快排序是用在数组中随机的选取一个数，与后面的数进行交换，来作为border。其时间复杂度为nlogn,空间负责度为n。
时间空间复杂度的求解均是通过数学公式取得的无限趋近与结果的值。

比如时间复杂度：在点正的时候，随机数选取刚好能把待排序的数据左右等分，然而每次都点正，所以概率为N/1同时时间复杂度为nlogn,通过对每个点的概率和时间复杂度乘积求和，可以得到总的时间复杂度，就是nlogn。

空间复杂度同理。每次都点正，就需要进行logn次，而每次点都不正，需要进行n次。依次加和他们的概率和空间复杂度，可得到logn。为什么是n呢，因为每次需要记录border的位置。递归几次就要记录几次。

所有排序： 选择排序，冒泡排序，插入排序，二分查找，堆排序，快速排序，归并排序
比较器：一个基于比较排序的规则。默认的规则是(在排序策略中一定不能形成环)
    - 第一个参数应该放在第二个参数前面(上面)返回-1；
    - 第二个参数应该放在第一个参数前面(上面)返回1；
    - 两个参数相等返回0；



桶排序：与比较没有关系。
    - 计数排序，知道一个数组的范围，申请一个和这个数组范围长度一样的数组，通过累计下标对应数字的个数来记录这个数在数组中出现了多少。然后还原这个记录的数组。没有比较数据。限制：上下限不能差的太远。
        + 比如：公司年龄排序;准备一个200长的数组，年龄是多少就在该下标的位置上+1；然后顺序还原即可。
    - 基数排序：找到最大的数，将剩下其位数补充为与其位数一样的数。
        + 排序: 13, 17, 60, 103, 213
        + 步骤：首先补全数字，在分别按照个位，十位，百位的权重来进桶出桶；