# 链表

- 单链表：next,val
- 双链表：next,last,val

- 链表习题
    + 双向链表，单向链表逆序
    + 打印公共链表部分。(思路：类似于并归指针)
    + 回文：进栈，出栈进行和原来对比，一样返回true。 优化：快慢指针(将后半部分压栈与前半部分对比。)->在优化(空间上：后半部分逆序，对比，调整回来)
    + 单项链表左右划分：遍历到数组结构，利用荷兰国旗划分，再根据数组结构连起来。  优化：放进三个桶里，再倒出连接。(时间优化)。 优化：准备六个变量，分别存储小头，小尾，中头，中尾，大头，大尾，利用链表的内部属性去连接(空间优化)。
    + 深度拷贝链表：使用哈希表。 优化：将克隆节点插入原节点和下一个节点中。由此每次通过原节点都可以找到拷贝节点。
    + 给定两个可能有环也可能无环的单链表，头节点head1和head2。请实 现一个函数，如果两个链表相交，请返回相交的 第一个节点。如果不相交，返回null。 
        * 先判断有环还是无环
            - 方法1：遍历链表，每次都放入哈希中，如果存在，则有环，并为成环点loop。
            - 方法2：快慢指针，快指针每次走两步，慢指针每次走一步。如果相遇则有环。慢指针留在再相遇的地方，快指针回到开头，继续都一步一步走。相遇的点就是成环点。
        * 判断是否相交
            - 都无环：
                + 查看最后节点是否一致，不一致则不相交。记录各个链表的长度。如果相交，长的链表先走长度的差值步。在一起走，看哪一步节点一致，则为相交点。
            - 都有环
                + 不相交
                    * 遍历一条链表，再遍历的过程中都没有遇到loop2，则不相交。
                + 环外相交
                    * 看loop1 == loop2 ？ 等于，环外相交。将相交点作为end，用都无环的方式寻找交点。
                + 环内相交
                    * 反之就是环内相交，可以返回loop1或者loop2

---
# 哈希表的简单介绍

- 多线程使用哈希表，一般来说使用锁进行解决，根底层没有关系，只是资源共享方面加了个锁。


---
# 有序表

- 可以实现有序表结构的结构：红黑树、AVL数、SB树、跳表
- 有序表必须要实现的功能
    + 查询有序表是否为空
    + 查询有序表大小
    + 插入数据
    + 得到值
    + 删除值
    + 返回最小key
    + 返回最大key
    + 返回小于等于key离他最近的key
    + 返回大于key离他最近的key